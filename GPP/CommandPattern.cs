//커맨드 패턴
/*
명령의 객체화?
명령을 함수로 표현하는 대신 명령어 객체 형태로 표현하자
명령을 객체로 저장할 수 있다

함수의 객체화? 그것의 장점?
C++: functer? 람다함수??????????
수행해야 할 내용을 펑터로 만들어서 넘겨준다?
콜백 함수를 객체 형태로 만듬
실행을 해야하는 내용의 입력정보> 어떻게 넘길건데?> 넘길때 그 정보가 존재하는지 어떻게 보장할건데?
인자가 없으면 프로그램이 뻗어버림
맴버변수 형태로 함수를 만들고....
메모리 관리와 연결되어있나?(가비지 콜렉션)

구성
인터페이스 클래스
    추상 클래스
    실행해야 하는 기능을 excute()메서드로 "선언"함
구체 클래스
    인터페이스를 구현하는 클래스
인보커
    커맨드 호출하는 클래스?
리시버
    커맨드를 수행하는 클래스?

C++나 자바의 경우 모든 클래스의 최상위 클래스는 Object(객체)

Integer vs int
Single vs float
Double vs double

뭐가 다른가?
오른쪽: 프리미티브 타입(컴파일러에서 제공하는 기본 자료형)
    보통 value타입으로 이동(복사된 정보가 넘어감)
왼쪽: 클래스 타입 
    레퍼런스 타입으로 존재(원본정보가 넘어감)

    왼/오 타입을 오가는 것을 (un)boxing 이라고 함

설계하는 관점에서 논리적으로 맞아도 "편의를 위해" 다른 방법을 택할 수 있어야한다

가상 소멸자?????
하위 클래스의 소멸자가 호출되는거 아닌가?
업캐스팅 되어서 소멸될때 다시 다운캐스팅하고 소멸시키면 되는거 아니오?> 굳이???
그냥 가상 소멸자 써서 원본 클래스의 소멸자 호출하면 간단함
버추얼이라는 키워드는 상/하위 클래스의 연결고리 역할
커맨드패턴 실행 도중 업캐스팅 된 커맨드를 소멸 시킬때 유용함

C#에서는 finalizer라는 것이 존재함(사실상 가상 소멸자)

참고
behavior pattern

#부족한 내용#
펑터, 람다함수
유니티 액션/이벤트
유니티 제네릭(C++에서는 탬플릿)

객체화해서 저장된 정보들을 시리얼라이즈(json등으로)
역정렬해서 재실행?

primitive type: value를 저장(일반적으로 스택에 저장)
    null 불가능
class type: reference를 저장(일반적으로 힙에 저장)
    null 가능
    heap공간 사용하면 메모리 파편화가 일어남> 자주 쓰는 정보는 구조체로 밸류타입으로 구현해서 사용(스택 이용)

자주 사용되는 (일정한)객체들은 포인팅만 해주는 방식으로 구현
*/
//구현

public class Command{
    public:
    virtual ~Command() {}//C#에서는 가비지 콜렉터 때문에 필요 없음(대신 finalizer)
    virtual void excute() = 0;
}

public JumpCommand:Command
{
public:
    virtual void excute() { jump(); }
}

public FireCommand:Command
{
public:
    virtual void excute() { fireGun(); }
}
//자식 클래스의 excute메서드의 구현을 서로 다르게 함

//옵저버 패턴

//길찾기 알고리즘
/*
가정
    n*n의 그리드 공간
    그리드 셀은 0번부터 n^2-1번중에 하나
    왼쪽 맨 아래가 0번, 오른쪽 맨위가 n^2-1번
    2차원 좌표: (x,y), 1차원 좌표: n*y + x

너비탐색
깊이탐색
A* 알고리즘

셀넘버<->좌표 상호 변환
이웃 셀넘버 구하기
    상하좌우 vs 상하좌우+대각선
문제의 분할
    목적지까지 도착할 수 있는가? Reachability
    도착가능할 때, 어떤 경로를 거쳐야 하는가? Reachability 판정시 사용한 정보를 기반으로 경로 구축

입력: 현재 위치, 도착 위치, 장애물 여부
출력: [위치1,위치2,....,도착지점]

BFS 알고리즘
    현재 이동한 노드 = 소스노드
    현재노드에서 다음에 이동 가능한 노드 확인
    이웃 노드중에 목적지가 있으면 지금까지이동한 노드 경로를 찾아내고 종료
    없으면 다음 이동할 노드들 집합에 넣는다
    집합의 노드중 소스와의 거리가 가장 짧은 노드들 중 하나를 선택
        선택할 노드가 없으면 종료
        선택한 노드를 이동할 노드 집합에서 삭제하고 첫단계로 이동

부족한 점
깊이/넓이 우선 탐색 개념, A*알고리즘 개념
*/


//중간과제
/*
중요한 것
커맨드 패턴에서 이동 구현과 리플레이
코드와 실행 영상 제출
*/