//커맨드 패턴
/*
명령의 객체화?
명령을 함수로 표현하는 대신 명령어 객체 형태로 표현하자
명령을 객체로 저장할 수 있다

함수의 객체화? 그것의 장점?
C++: functer? 람다함수??????????
수행해야 할 내용을 펑터로 만들어서 넘겨준다?
콜백 함수를 객체 형태로 만듬
실행을 해야하는 내용의 입력정보> 어떻게 넘길건데?> 넘길때 그 정보가 존재하는지 어떻게 보장할건데?
인자가 없으면 프로그램이 뻗어버림
맴버변수 형태로 함수를 만들고....
메모리 관리와 연결되어있나?(가비지 콜렉션)

구성
인터페이스 클래스
    추상 클래스
    실행해야 하는 기능을 excute()메서드로 "선언"함
구체 클래스
    인터페이스를 구현하는 클래스
인보커
    커맨드 호출하는 클래스?
리시버
    커맨드를 수행하는 클래스?

C++나 자바의 경우 모든 클래스의 최상위 클래스는 Object(객체)

Integer vs int
Single vs float
Double vs double

뭐가 다른가?
오른쪽: 프리미티브 타입(컴파일러에서 제공하는 기본 자료형)
    보통 value타입으로 이동(복사된 정보가 넘어감)
왼쪽: 클래스 타입 
    레퍼런스 타입으로 존재(원본정보가 넘어감)

    왼/오 타입을 오가는 것을 (un)boxing 이라고 함

설계하는 관점에서 논리적으로 맞아도 "편의를 위해" 다른 방법을 택할 수 있어야한다

가상 소멸자?????
하위 클래스의 소멸자가 호출되는거 아닌가?
업캐스팅 되어서 소멸될때 다시 다운캐스팅하고 소멸시키면 되는거 아니오?> 굳이???
그냥 가상 소멸자 써서 원본 클래스의 소멸자 호출하면 간단함
버추얼이라는 키워드는 상/하위 클래스의 연결고리 역할
커맨드패턴 실행 도중 업캐스팅 된 커맨드를 소멸 시킬때 유용함

C#에서는 finalizer라는 것이 존재함(사실상 가상 소멸자)

참고
behavior pattern

#부족한 내용#
펑터, 람다함수
유니티 액션/이벤트
유니티 제네릭(C++에서는 탬플릿)

객체화해서 저장된 정보들을 시리얼라이즈(json등으로)
역정렬해서 재실행?

primitive type: value를 저장(일반적으로 스택에 저장)
    null 불가능
class type: reference를 저장(일반적으로 힙에 저장)
    null 가능
    heap공간 사용하면 메모리 파편화가 일어남> 자주 쓰는 정보는 구조체로 밸류타입으로 구현해서 사용(스택 이용)

자주 사용되는 (일정한)객체들은 포인팅만 해주는 방식으로 구현
*/
//구현

public class Command{
    public:
    virtual ~Command() {}//C#에서는 가비지 콜렉터 때문에 필요 없음(대신 finalizer)
    virtual void excute() = 0;
}

public JumpCommand:Command
{
public:
    virtual void excute() { jump(); }
}

public FireCommand:Command
{
public:
    virtual void excute() { fireGun(); }
}
//자식 클래스의 excute메서드의 구현을 서로 다르게 함

//옵저버 패턴

//길찾기 알고리즘
/*
가정
    n*n의 그리드 공간
    그리드 셀은 0번부터 n^2-1번중에 하나
    왼쪽 맨 아래가 0번, 오른쪽 맨위가 n^2-1번
    2차원 좌표: (x,y), 1차원 좌표: n*y + x

너비탐색
깊이탐색
A* 알고리즘

셀넘버<->좌표 상호 변환
이웃 셀넘버 구하기
    상하좌우 vs 상하좌우+대각선
문제의 분할
    목적지까지 도착할 수 있는가? Reachability
    도착가능할 때, 어떤 경로를 거쳐야 하는가? Reachability 판정시 사용한 정보를 기반으로 경로 구축

입력: 현재 위치, 도착 위치, 장애물 여부
출력: [위치1,위치2,....,도착지점]

BFS 알고리즘
    현재 이동한 노드 = 소스노드
    현재노드에서 다음에 이동 가능한 노드 확인
    이웃 노드중에 목적지가 있으면 지금까지이동한 노드 경로를 찾아내고 종료
    없으면 다음 이동할 노드들 집합에 넣는다
    집합의 노드중 소스와의 거리가 가장 짧은 노드들 중 하나를 선택
        선택할 노드가 없으면 종료
        선택한 노드를 이동할 노드 집합에서 삭제하고 첫단계로 이동

부족한 점
깊이/넓이 우선 탐색 개념, A*알고리즘 개념
*/


//중간과제
/*
중요한 것
커맨드 패턴에서 이동 구현과 리플레이
코드와 실행 영상 제출
*/

//0502 수업내용
/*
람다함수: 어떤것을 실행해줄 수 있는 객체, 실행에 필요한 것을 멤버변수로 가지고있음

콜백함수의 장점이자 단점
비동기성: 생성시점과 동작시점이 다르다
->그래서 전역함수나 스태틱으로 선언
*/

/*
Observer Pattern
유니티에서는 아주 단순하게 구현되어있음

그래서 뭔데?
자신이 가진 기능에 없는 함수를 찾아 직접 호출하는 대신
어떤 이벤트를 관리하는 주체에게 메시지를 받아 기능을 실행

예)
게임매니저
UI
게임루프
일때, UI가 떴을때 게임루프는 잠시 멈추고 UI사라지면 재개함

게임루프는 게임 매니저에게 UI가 나왔다는 메시지를 받음 -> 멈춤
나중에 사라졌다는 메시지 받음 -> 재개

이 상황에서 
옵저버(주체): 게임매니저
이벤트 발생하는 놈: UI
이벤트 구독하는 놈: 게임루프
*/

//0509 수업내용
/*
유니티에서 옵저버 패턴 사용

delegate: 함수 포인터-> 어떤 함수들 마다 시그니처가 있다. 
시그니처-> 함수의 입/출력(입력변수,반환형)
함수의 자료구조화? 함수가 자료형인 것 처럼, 변수인 것 처럼

변수로 만들기 위해> 자료형, 이름 등이 필요함

그래서 함수포인터 쓰면 뭐가 좋은데?
함수를 입력 파라미터로 넘길 수 있다 -> 실행해야 할 함수를 넘길 수 있다.
어떤 함수를 가리키고 있다가 다른 함수로 바꿀 수 있음 -> 함수포인터만 실행해주고 포인터가 가리키는 함수만 바꿔주면 됨
쓰면 멋져보임 POV: bro's Aura +99999999999999999999999999999999999

그런데
사실상 상속 모델에서 오버라이드 사용하는거나 다름없음

C#에서는
public delegate (int: 자료형) (FunctionPointer: 이름)((string: 입력변수?))

delegate 반환형 델리게이트명(매개변수, 매개변수, 매개변수, ....);
delegate int ExDelegate(int no, string name);

멀티캐스트 호출?이 가능하다
함수 포인터가 가리키는 함수가 여러 함수를 포함하고 있다면 전부 실행시켜줄 수 있다

함수포인터에 함수를 추가할 떄
함포 += 함수;
하나만 추가할 때
함포 = 함수;

둘이 다른거임!!!!!!!!!

멀티캐스팅 주의점

여러개 값을 반환하면?
>마지막에 호출된 값을 반환

등록된 순서 조정 가능??

가입 / 해제 시점 주의
>On Enable/Disable 활용

event
>public event FunctionPointer func;
이벤트는 add, remove(+=, -=) 기능만 제공하고 assign(=) 기능은 제공하지 않음

Action
입력 인자는 있지만 반환형이 없는것 -> 실행하는 것에만 초점을 맞춤

VS

Func
반환형까지 있는것 -> 일반적인 함수의 기능을 제공

UnityEvent? 이거는 뭔지 알아볼것

UnityEvent vs event
기능적으로는 같음

그럼 뭐가 다르냐?
네임스페이스
인스펙터 이용
유> 인스펙터 노출 가능
이> 인스펙터 안보임

성능
유> 느림(Reflection 사용: 이름으로 찾는다는 말)
이> 빠름(직접 delegate 호출)

결과적으로
구현할때는 유니티 이벤트 쓰고(편하니까),
마지막에는 이벤트로 바꿔서 성능을 갖춰라

##########################################################

Singleton Pattern
클래스당 한개의 인스턴스를 갖도록 보장하고, 이에 대한 전역정인 접근점을 제공

-스태틱이라는 키워드를 어떻게 해석해야 하는가?
객체지향의 적??? -> 객체화시키지 않고 사용할 수 있는건 객체지향적이지 않다

스태틱 지역변수로 싱글톤 객체를 초기화 하면?
>처음 실행될때만 초기화되고 외부에서 다시 실행할때는 이미 존재하는 변수이기 때문에 접근하지 않는다
>그런데 해제할 떄는 어떻게 함? 접근할 수가 없는데?
잘 모름...

싱글톤의 특징
필요하지 않느면 인스턴스를 생성하지 않음
런타임에 초기화됨(게으른 초기화)
    >정적 변수/함수 사용하면 자동 초기화됨
        >단점: 프로그램 실행시 알 수 있는 정보 활용 불가
상속 가능

싱글톤 남용하면? social credit -99999999999
-결국 전역변수
>코드 이해가 어렵다
    쓰기는 편한데 수정할 때는 관련된 모든 코드를 들여다 봐야됨
>커플링 조장
    싱글톤이 이미 있으면 필요할때마다 쓰고싶지 않겠음???
    >인스턴스에 대한 접근을 통제해서 커플링 통제할 수 있음
>멀티스레딩 같은 동시성 프로그래밍에 부적합
    스레드 동기화 버그는 진.짜.겁.나.어.려.움

싱글톤은 치료제라기보단 진정제에 가깝다고 한다...

-인스턴스는 하나로 하고싶지만 전역 접근은 원하지 않을때
-클래스를 전역 접근하고 싶지만 인스턴스는 여러개로 하고싶을때

-게으른 초기화는 제어가 어려움
>전투 도중에 lazy initialization이 호출된다면? -> 프레임 드랍
>그래서 게으른 초기화 안하고 쓰려면 어떻게 되는데
    다형성 쓰지 마
    메모리 해제 하지 마

싱글톤의 대안
>다른 객체를 관리하는 용도로 사용하는 경우 > Manager, Engine, System 등과 같은 이름을 쓰는 클래스들

>인스턴스 하나 갖기 보장
초기화 변수 사용: 하나만 쓰려했는데 다른데서 또 호출한다?
    바로 그냥 프로그램 죽이고 호출한놈 로그로 띄워버려
    >어디서 문제 생긴건지 알기 쉬음

>인스턴스에 쉽게 접근
    이미 전역인 객체로부터 얻기?
        파사드 패턴
잘 모르겠네...

0516 수업

restful api?
rest api?

hugging face 찾아보기
streamlit vs Dash (UI,UX)
fast api vs flask

다음시간
flask, dash, streamlit 등을 이용해볼거임

*/